<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8' />
    <meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
      <link rel='stylesheet' href="style.css" type='text/css' />
  </head>
  
  
  <body style='background: #691A0E;'><center><table border=0 id='wrapper'>
    <tr><td colspan=2 id='headtd'>
      Лабораторная работа <span id='headdm'>№4</span>
    </td></tr>
	
<tr><td id='navtd'>	
<table border=0 width='20%'>
  <table border=0 cellpadding=1 id='restable'>
    <tr id='reshead'>
      <th><span style='font-size: 13px'><b class='canBeLong'>Навигация</b><br/>
        </span></th>
    </tr>
	 <tr class='odd'><td><span class='navitem'><a href='1.htm'>Главная страница</a></span></td>
	 <tr class='odd'><td><span class='navitem'><a href='help.htm' class='current'>Алгоритм программы</a></span></td></tr>
	 <tr class='odd'><td><span class='navitem'><a href='about_graph.htm'>Работа с графом</a></span></td></tr>
	 
	<tr><td></td></tr><tr><td></td></tr>
	 <tr><td><center><img src="moevm_small.png" id="lower"></center></td></tr>
	 <tr><td><b>СПбГЭТУ "ЛЭТИ" Кафедра МОЭВМ 2018</b></td></tr>
	 </table>
	 
  </td>
   </td><td id='bodytd'>	
   
   

<table border=0 width='100%'>
<tr><td width='100%' valign='top'>

<h1 style='padding-bottom: 14px'><center>Алгоритм работы</center></h1>
<big><big><big><big><h3>

<p>Под сетью мы будем понимать пару S = (G, c), где G = (V,E) — произвольный
ориентированный граф, а c : E → R — функция, которая каждой дуге (v, u)
ставит в соответствие неотрицательное вещественное число c(u, v), называемое
пропускной способностью этой дуги. Множества V и E называются
соответственно множеством вершин и множеством дуг сети S</p>

<h1 style='padding-bottom: 14px'><center>Алгоритм нахождения максимального потока</center></h1>

<p>Обозначим количество вершин в графе как переменную size.
Объявим 2 двумерных массива размера size x size для хранения пропускной способности и потока для заданных вершин (capacity и flow).</p>
<p>Например, если через вершины 1 и 2 есть поток равный 3, а пропускная способность - 4, тогда организация хранения данной
информации в массивах будет выглядеть следующим образом: flow[1][2] = 3, capacity[1][2] = 4. До запуска алгоритма массив
flow инициализирован нулями.</p>
<p>Для нахождения путей между двумя заданными точками реализуем функцию bfs.</p>

<p>Зададим сток (stock) и исток (source).
Пока существуют пути между stock и source найденные через bfs, выполняем алгоритм нахождения максимального потока.
Для этого заведем переменную delta, отвечающую за изменение потока. Функция bfs возвращает одномерный массив pred
(найденный путь). Пройдемся по заданному пути и найдем минимальное значение delta, определенное следующим образом:
delta = min(delta, разность между пропускной способностью и потоком для каждого ребра найденного пути). После этого
увеличим значение потока на величину delta для каждого ребра пути.</p>

<h1 style='padding-bottom: 14px'><center>Алгоритм поиска в ширину</center></h1>

<p>bfs - алгоритм поиска в ширинуоснован на алгоритме из книги Липского (*).</p>

<p>Дополнительным условием является проверки вершины на корректность существования потока (пропускная способность всегда должна быть больше потока).
Функция bfs возвращается true или false в зависимости от существования пути между заданными вершинами. Также функция
модифицирует одномерный массив pred в котором записывается путь в определенном виде. </p>Рассмотрим пример №2, первый обход
функции bfs. Результат: pred = [-1,0,0,1,2,3]. Интерпретация полученного массива в путь выглядит следующим образом
(нумерация с 0): Начинаем с конца, последняя вершина 5. pred[5] = 3 => вторая вершина 3. pred[3] = 1, pred[1] = 0, pred[0] = -1 - конец. Получаем путь 5-3-1-0.


<p></p><p></p><p></p>
<p>&nbsp;&nbsp;(*) - В. Липский. Комбинаторика для программиста. М. &laquo;Мир&raquo;, 1988.</p>

  </h3></big></big></big></big>
  </td>
  </tr>
  
</table>
    </td></tr>
    <tr><tr><tr><tr><td colspan="2" id="foottd"><center><img src="spbctf.png" id="lower">  Coded by kovinevmv, 2018</center></td></tr></tr></tr></tr>
    </tr>
  </table></center>
   
  </body>
</html>

